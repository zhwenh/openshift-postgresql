#!/bin/bash
#
# Test the PostgreSQL image.
#
# IMAGE_NAME specifies the name of the candidate image used for testing.
# The image has to be available before this script is executed.
#

set -exo nounset
shopt -s nullglob

. test/test_lib

TEST_LIST="\
run_upgrade_test
run_migration_test
run_container_creation_tests
run_general_tests
run_change_password_test
run_replication_test
run_master_restart_test
run_doc_test
"

test $# -eq 1 -a "${1-}" == --list && echo "$TEST_LIST" && exit 0
test -n "${IMAGE_NAME-}" || false 'make sure $IMAGE_NAME is defined'
test -n "${VERSION-}" || false 'make sure $VERSION is defined'
test -n "${OS-}" || false 'make sure $OS is defined'

CIDFILE_DIR=$(mktemp --suffix=postgresql_test_cidfiles -d)

function cleanup() {
  script_exit_status=$?

  for cidfile in $CIDFILE_DIR/* ; do
    CONTAINER=$(cat $cidfile)

    echo "Stopping and removing container $CONTAINER..."
    docker stop $CONTAINER

    if test 0 -ne $script_exit_status -o \
            0 -ne "$(docker inspect -f '{{.State.ExitCode}}' $CONTAINER)"
    then
      echo "Dumping logs for $CONTAINER"
      docker logs $CONTAINER
    fi
    docker rm $CONTAINER
    rm $cidfile
    echo "Done."
  done
  test ! -z "${DOCKER_NETS-}" && docker network rm $DOCKER_NETS
  rmdir $CIDFILE_DIR

  for dir in ${VOLUME_DIRS-}; do
    cleanup_pg_volume_dir $dir
  done
}
trap cleanup EXIT


# When we run this test script as non-root (we should?), the PostgreSQL server
# within container is still run under 'postgres' user.  It means that, taking
# into account 0077 umask of PostgreSQL server, we are unable to remove files
# created by server.  That's why we need to let docker escalate the privileges
# again.
function cleanup_pg_volume_dir() {
  local volume_dir="$1"
  local volume_args="-v ${volume_dir}:/var/lib/pgsql/data:Z"
  local rm_cmd='/bin/rm -rf /var/lib/pgsql/data/*'
  docker run $volume_args --rm $IMAGE_NAME /bin/sh -c "$rm_cmd"
  rmdir ${volume_dir}
}

function get_cid() {
  local id="$1" ; shift || return 1
  echo $(cat "$CIDFILE_DIR/$id")
}

function get_container_ip() {
  local id="$1" ; shift
  local net=${network:-bridge}
  docker inspect --format="{{.NetworkSettings.Networks.$net.IPAddress}}" $(get_cid "$id")
}

function get_ip_from_cid() {
  local cid="$1"; shift
  local net=${network:-bridge}
  docker inspect --format="{{.NetworkSettings.Networks.$net.IPAddress}}" $cid
}

function postgresql_cmd() {
  docker run --rm ${psql_docker_args:-} -e PGPASSWORD="${PASS}" $IMAGE_NAME psql postgresql://$PGUSER@$CONTAINER_IP:5432/"${DB-db}" "$@"
}

function test_connection() {
  local name=$1 ; shift
  ip=$(get_container_ip $name)
  echo "  Testing PostgreSQL connection to $ip..."
  local max_attempts=20
  local sleep_time=2
  for i in $(seq $max_attempts); do
    echo "    Trying to connect..."
    set +e
    # Don't let the code come here if neither user nor admin is able to
    # connect.
    if [ -v PGUSER ] && [ -v PASS ]; then
      CONTAINER_IP=$ip postgresql_cmd <<< "SELECT 1;"
    else
      PGUSER=postgres PASS=$ADMIN_PASS CONTAINER_IP=$ip DB=postgres postgresql_cmd <<< "SELECT 1;"
    fi
    status=$?
    set -e
    if [ $status -eq 0 ]; then
      echo "  Success!"
      return 0
    fi
    sleep $sleep_time
  done
  return 1
}

function test_postgresql() {
  echo "  Testing PostgreSQL"
  postgresql_cmd <<< "CREATE EXTENSION 'uuid-ossp';" # to test contrib package
  postgresql_cmd <<< "CREATE TABLE tbl (col1 VARCHAR(20), col2 VARCHAR(20));"
  postgresql_cmd <<< "INSERT INTO tbl VALUES ('foo1', 'bar1');"
  postgresql_cmd <<< "INSERT INTO tbl VALUES ('foo2', 'bar2');"
  postgresql_cmd <<< "INSERT INTO tbl VALUES ('foo3', 'bar3');"
  postgresql_cmd <<< "SELECT * FROM tbl;"
  #postgresql_cmd <<< "DROP TABLE tbl;"
  echo "  Success!"
}

function create_container() {
  local name=$1 ; shift
  local cargs=${DOCKER_ARGS:-}
  cidfile="$CIDFILE_DIR/$name"
  # create container with a cidfile in a directory for cleanup
  docker run $cargs --cidfile $cidfile -d $IMAGE_NAME "$@"
  echo "Created container $(cat $cidfile)"
}

function create_pg_volume_dir () {
  volume_dir=`mktemp -d --tmpdir pg-testdata.XXXXX`
  VOLUME_DIRS="${VOLUME_DIRS-} $volume_dir"
  # Give only the necessary permissions.  We don't test the "arbitrary" uid
  # feature so far.
  setfacl -m u:26:rwx ${volume_dir}
}

function assert_login_access() {
  local PGUSER=$1 ; shift
  local PASS=$1 ; shift
  local success=$1 ; shift

  echo "testing login as $PGUSER:$PASS; should_success=$success"

  if postgresql_cmd <<<'SELECT 1;' ; then
    if $success ; then
      echo "    $PGUSER($PASS) access granted as expected"
      return
    fi
  else
    if ! $success ; then
      echo "    $PGUSER($PASS) access denied as expected"
      return
    fi
  fi
  echo "    $PGUSER($PASS) login assertion failed"
  exit 1
}

function assert_local_access() {
  local id="$1" ; shift
  docker exec -i $(get_cid "$id") bash -c psql <<< "SELECT 1;"
}


# Make sure the invocation of docker run fails.
function assert_container_creation_fails() {

  # Time the docker run command. It should fail. If it doesn't fail,
  # postgresql will keep running so we kill it with SIGKILL to make sure
  # timeout returns a non-zero value.
  set +e
  timeout -s 9 --preserve-status 60s docker run --rm "$@" $IMAGE_NAME
  ret=$?
  set -e

  # Timeout will exit with a high number.
  if [ $ret -gt 30 ]; then
    return 1
  fi
}

function try_image_invalid_combinations() {
  assert_container_creation_fails -e POSTGRESQL_USER=user -e POSTGRESQL_PASSWORD=pass "$@"
  assert_container_creation_fails -e POSTGRESQL_USER=user -e POSTGRESQL_DATABASE=db "$@"
  assert_container_creation_fails -e POSTGRESQL_PASSWORD=pass -e POSTGRESQL_DATABASE=db "$@"
}

function run_container_creation_tests() {
  echo "  Testing image entrypoint usage"
  try_image_invalid_combinations
  try_image_invalid_combinations  -e POSTGRESQL_ADMIN_PASSWORD=admin_pass

  VERY_LONG_IDENTIFIER="very_long_identifier_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
  assert_container_creation_fails -e POSTGRESQL_USER=0invalid -e POSTGRESQL_PASSWORD=pass -e POSTGRESQL_DATABASE=db -e POSTGRESQL_ADMIN_PASSWORD=admin_pass
  assert_container_creation_fails -e POSTGRESQL_USER=$VERY_LONG_IDENTIFIER -e POSTGRESQL_PASSWORD=pass -e POSTGRESQL_DATABASE=db -e POSTGRESQL_ADMIN_PASSWORD=admin_pass
  assert_container_creation_fails -e POSTGRESQL_USER=user -e POSTGRESQL_PASSWORD="\"" -e POSTGRESQL_DATABASE=db -e POSTGRESQL_ADMIN_PASSWORD=admin_pass
  assert_container_creation_fails -e POSTGRESQL_USER=user -e POSTGRESQL_PASSWORD=pass -e POSTGRESQL_DATABASE=9invalid -e POSTGRESQL_ADMIN_PASSWORD=admin_pass
  assert_container_creation_fails -e POSTGRESQL_USER=user -e POSTGRESQL_PASSWORD=pass -e POSTGRESQL_DATABASE=$VERY_LONG_IDENTIFIER -e POSTGRESQL_ADMIN_PASSWORD=admin_pass
  assert_container_creation_fails -e POSTGRESQL_USER=user -e POSTGRESQL_PASSWORD=pass -e POSTGRESQL_DATABASE=db -e POSTGRESQL_ADMIN_PASSWORD="\""
  echo "  Success!"
}

function test_config_option() {
  local name=$1 ; shift
  local setting=$1 ; shift
  local value=$1 ; shift

  docker exec $(get_cid ${name}) grep -q "${setting} = ${value}" /var/lib/pgsql/openshift-custom-postgresql.conf
}

function run_configuration_tests() {
  local name=$1 ; shift
  echo "  Testing image configuration settings"
  test_config_option ${name} max_connections ${POSTGRESQL_MAX_CONNECTIONS}
  test_config_option ${name} max_prepared_transactions ${POSTGRESQL_MAX_PREPARED_TRANSACTIONS}
  test_config_option ${name} shared_buffers ${POSTGRESQL_SHARED_BUFFERS}
  echo "  Success!"
}

test_scl_usage() {
  local name="$1"
  local run_cmd="$2"
  local expected="$3"

  echo "  Testing the image SCL enable"
  out=$(docker run --rm ${IMAGE_NAME} /bin/bash -c "${run_cmd}")
  if ! echo "${out}" | grep -q "${expected}"; then
    echo "ERROR[/bin/bash -c "${run_cmd}"] Expected '${expected}', got '${out}'"
    return 1
  fi
  out=$(docker exec $(get_cid $name) /bin/bash -c "${run_cmd}" 2>&1)
  if ! echo "${out}" | grep -q "${expected}"; then
    echo "ERROR[exec /bin/bash -c "${run_cmd}"] Expected '${expected}', got '${out}'"
    return 1
  fi
  out=$(docker exec $(get_cid $name) /bin/sh -ic "${run_cmd}" 2>&1)
  if ! echo "${out}" | grep -q "${expected}"; then
    echo "ERROR[exec /bin/sh -ic "${run_cmd}"] Expected '${expected}', got '${out}'"
    return 1
  fi
}


function run_tests() {
  echo "  Testing general usage (run_tests) with '$1' as argument"
  local name=$1 ; shift

  user_login=false
  admin_login=false
  envs=
  # NOTE: We work wrongly with variables so please don't try to pass spaces
  # within PGUSER/PASS/ADMIN_PASS variables.
  [ -v PGUSER ] && envs+=" -e POSTGRESQL_USER=$PGUSER"
  [ -v PASS ] && envs+=" -e POSTGRESQL_PASSWORD=$PASS"
  if [ -v PGUSER ] && [ -v PASS ]; then
    envs+=" -e POSTGRESQL_DATABASE=db"
    user_login=:
  fi

  if [ -v ADMIN_PASS ]; then
    envs="$envs -e POSTGRESQL_ADMIN_PASSWORD=$ADMIN_PASS"
    admin_login=:
  fi
  if [ -v POSTGRESQL_MAX_CONNECTIONS ]; then
    envs="$envs -e POSTGRESQL_MAX_CONNECTIONS=$POSTGRESQL_MAX_CONNECTIONS"
  fi
  if [ -v POSTGRESQL_MAX_PREPARED_TRANSACTIONS ]; then
    envs="$envs -e POSTGRESQL_MAX_PREPARED_TRANSACTIONS=$POSTGRESQL_MAX_PREPARED_TRANSACTIONS"
  fi
  if [ -v POSTGRESQL_SHARED_BUFFERS ]; then
    envs="$envs -e POSTGRESQL_SHARED_BUFFERS=$POSTGRESQL_SHARED_BUFFERS"
  fi
  DOCKER_ARGS="${DOCKER_ARGS:-} $envs" create_container $name
  CONTAINER_IP=$(get_container_ip $name)
  test_connection $name
  echo "  Testing scl usage"
  test_scl_usage $name 'psql --version' "$VERSION"

  echo "  Testing login accesses"
  assert_login_access "${PGUSER:-}"     "${PASS-}"            "$user_login"
  assert_login_access "${PGUSER:-}"     "${PASS-}_foo"        false

  assert_login_access postgres          "${ADMIN_PASS-}"      "$admin_login"
  assert_login_access postgres          "${ADMIN_PASS-}_foo"  false

  assert_local_access $name
  run_configuration_tests $name
  echo "  Success!"

  if $user_login; then
    test_postgresql $name
  fi

  if $admin_login; then
    DB=postgres PGUSER=postgres PASS=$ADMIN_PASS test_postgresql $name
  fi
}

# run_replication_container {master|slave} IP PRETTY_NAME [CID_SUFFIX]
# --------------------------------------------------------------------
# Consumes also '$network', '$cid_suffix', '$test_random_id', '$cluster_args'
# and either $master_args or $slave_args (based on the first argument).
run_replication_container ()
{
  local container_args=
  eval "container_args+=\${${1}_args-}"
  docker run $cluster_args ${container_args} \
        --name $test_random_id-postgresql-$VERSION-$3 \
        -e POSTGRESQL_MASTER_IP=$master_ip \
        --net=$network --ip=$2 \
        -d --cidfile ${CIDFILE_DIR}/$1-${cid_suffix}${4+-$4}.cid \
        $IMAGE_NAME run-postgresql-$1
}

function test_slave_visibility() {
  local max_attempts=30
  for slave_ip in $slave_ips; do
    : "checking master visibility from slave: $slave_ip"
    for i in $(seq $max_attempts); do
      result="$(postgresql_cmd -c "select client_addr from pg_stat_replication;" | grep "$slave_ip" || true)"
      if [[ -n "${result}" ]]; then
        echo "${slave_ip} successfully registered as SLAVE for ${master_ip}"
        break
      fi
      test $i -lt $max_attempts
      sleep 1
    done
  done
}

function test_value_replication() {
  local max_attempts=30

  # Setup the replication data
  local value
  value=24
  postgresql_cmd -c "CREATE TABLE $table_name (a integer); INSERT INTO $table_name VALUES ($value);"

  # Read value from slaves and check whether it is expected
  for slave_ip in $slave_ips; do
    CONTAINER_IP=$slave_ip
    for i in $(seq $max_attempts); do
      result="$(postgresql_cmd -At -c "select * from $table_name" || :)"
      if [[ "$result" == "$value" ]]; then
        echo "${slave_ip} successfully got value from MASTER ${master_ip}"
        break
      fi
      test $i -lt $max_attempts
      sleep 1
    done
  done
}


# critical_section LOCK_FILE CMD [ARGS...]
# -------------------------------------------
# Use LOCK_FILE as a semaphore before running shell CMD.  Flock tool from
# util-linux is used to lock the file for time being.  We don't clean the file,
# so ideally put the file somewhere were it is going to be garbage collected.
critical_section()
(
    file=$1 ; shift
    while :; do
        # TODO: sleep or not?
        flock -n 9 || continue
        : running the command in critical section!
        "$@"
        exit $?
    done 9>"$1"
)


# random_string VARNAME LENGTH=16
# -------------------------------
# Set $VARNAME to random string of length $LENGTH.
random_string ()
{
    local val=$(cat /dev/urandom | LC_ALL=C tr -dc "[:alpha:]" | head -c ${2-16})
    eval $1=\$val
}

# allocate_docker_network NAME
# ----------------------------
# Create docker network usable with --net && --ip parameters later (craeting the
# network requires explicitly specified --subnet).  Make sure the network of
# name NAME does not exist, yet.
allocate_docker_network ()
{
  local name pattern found check

  name="$1"
  pattern=172.18.X.0

  found=false
  for check in {1..255}
  do
    # Hack!  Docker should perform atomic network-creation!
    critical_section "/var/tmp/docker-networks.lock" \
    docker network create --driver bridge \
            --subnet=${pattern//X/$check}/24 "$name" \
        || continue
    found=:
    DOCKER_NETS="${DOCKER_NETS:-} $name"
    break
  done

  # Error when we were unable to find free subnet.
  $found || false "can not allocate Docker network with IP pattern '$pattern'"

  network=$name
  network_ip=${pattern//X/$check}
}

create_pg_network ()
{
  allocate_docker_network "${test_random_id}_postgresql_${VERSION}"
}

# allocate_ip
# -----------
# Based on $network variable, generate lowest unused IP address as $allocated_ip
# variable.
allocate_ip ()
{
  # Make sure IP_LOOKUP_TABLE is declared "globally"
  test -n "${IP_LOOKUP_TABLE[*]-}" || declare -g -A IP_LOOKUP_TABLE

  local network_base=${network_ip%%.0}

  # Search for the last used IP, or start from 1.
  allocated_ip=${IP_LOOKUP_TABLE[$network_base]-1}

  # Increment and remember the last used IP.
  allocated_ip=$(( allocated_ip + 1 ))
  IP_LOOKUP_TABLE[$network_base]=$allocated_ip

  # "export" the resulting IP address
  allocated_ip="${network_base}.$allocated_ip"
}


function setup_replication_cluster() {
  create_pg_network
  psql_docker_args="${psql_docker_args-} --net=$network"

  # Run the PostgreSQL master
  allocate_ip
  master_ip=$allocated_ip
  run_replication_container master "$master_ip" master

  # Run the PostgreSQL slaves
  local i
  for i in $(seq ${slave_num:-1}); do
    allocate_ip
    run_replication_container slave "$allocated_ip" slave-$i $i
    slave_ips="$slave_ips $allocated_ip"
  done
}

function run_master_restart_test() {
  local DB=postgres
  local PGUSER=master
  local PASS=master

  echo "Testing failed master restart"
  local cid_suffix="mrestart"
  local cluster_args="-e POSTGRESQL_ADMIN_PASSWORD=pass -e POSTGRESQL_MASTER_USER=$PGUSER -e POSTGRESQL_MASTER_PASSWORD=$PASS"
  local table_name="t1"

  local volume_dir
  create_pg_volume_dir
  local master_args="-v ${volume_dir}:/var/lib/pgsql/data:Z"

  # Setup the cluster, keep exported vars local only.
  local network network_ip master_ip slave_ips= psql_docker_args
  slave_num=2 setup_replication_cluster

  # Check if the master knows about the slaves
  CONTAINER_IP=$master_ip
  test_slave_visibility

  : "Kill the master and create a new one"
  docker kill "$(cat "$CIDFILE_DIR/master-$cid_suffix.cid")"
  run_replication_container master "$master_ip" master-restarted restarted

  # Check if the new master sees existing slaves
  test_slave_visibility

  # Check if the replication works
  table_name="t1" test_value_replication
}

function run_replication_test() {
  local DB=postgres
  local PGUSER=master
  local PASS=master

  echo "Testing master-slave replication"
  local cluster_args="-e POSTGRESQL_ADMIN_PASSWORD=pass -e POSTGRESQL_MASTER_USER=$PGUSER -e POSTGRESQL_MASTER_PASSWORD=$PASS"
  local cid_suffix="basic"

  # Setup the cluster, keep exported vars local only.
  local network network_ip master_ip slave_ips= psql_docker_args
  setup_replication_cluster

  # Check if the master knows about the slaves
  CONTAINER_IP=$master_ip
  test_slave_visibility

  # Do some real work to test replication in practice
  table_name="t1" test_value_replication
}

function run_change_password_test() {
  echo "  Testing password change"
  local name="change_password"

  local database='db'
  local user='user'
  local password='password'
  local admin_password='adminPassword'

  local volume_dir
  create_pg_volume_dir
  local volume_options="-v ${volume_dir}:/var/lib/pgsql/data:Z"

  DOCKER_ARGS="
-e POSTGRESQL_DATABASE=${database}
-e POSTGRESQL_USER=${user}
-e POSTGRESQL_PASSWORD=${password}
-e POSTGRESQL_ADMIN_PASSWORD=${admin_password}
$volume_options
" create_container ${name}

  # need to set these because `postgresql_cmd` relies on global variables
  PGUSER=${user}
  PASS=${password}

  # need this to wait for the container to start up
  CONTAINER_IP=$(get_container_ip ${name})
  test_connection ${name}

  echo "  Testing login"

  assert_login_access ${user} ${password} true
  assert_login_access 'postgres' ${admin_password} true

  echo "  Changing passwords"

  docker stop $(get_cid ${name})
  DOCKER_ARGS="
-e POSTGRESQL_DATABASE=${database}
-e POSTGRESQL_USER=${user}
-e POSTGRESQL_PASSWORD=NEW_${password}
-e POSTGRESQL_ADMIN_PASSWORD=NEW_${admin_password}
$volume_options
" create_container "${name}_NEW"

  # need to set this because `postgresql_cmd` relies on global variables
  PASS="NEW_${password}"

  # need this to wait for the container to start up
  CONTAINER_IP=$(get_container_ip "${name}_NEW")
  test_connection "${name}_NEW"

  echo "  Testing login with new passwords"

  assert_login_access ${user} "NEW_${password}" true
  assert_login_access ${user} ${password} false

  assert_login_access 'postgres' "NEW_${admin_password}" true
  assert_login_access 'postgres' ${admin_password} false

  echo "  Success!"
}

run_upgrade_test ()
{
    local upgrade_path="none 9.2 9.4 9.5 9.6 none" prev= act=
    for act in $upgrade_path; do
        if test "$act" = $VERSION; then
            break
        fi
        prev=$act
    done
    test "$prev" != none

    # TODO: We run this script from $VERSION directory, through test/run symlink.
    test/run_upgrade_test "$prev:remote" "$VERSION:local"
}

run_migration_test ()
{
    local from_version
    local upgrade_path="9.2 9.4 9.5 9.6"

    for from_version in $upgrade_path; do
        # Do not test migration from $VERSION:remote to $VERSION:local
        test $(version2number $from_version) -lt $(version2number "$VERSION") \
            || break
        test/run_migration_test $from_version:remote $VERSION:local
    done
}

run_doc_test() {
  local tmpdir=$(mktemp -d)
  local f
  echo "  Testing documentation in the container image"
  # Extract the help files from the container
  for f in help.1 ; do
    docker run --rm ${IMAGE_NAME} /bin/bash -c "cat /${f}" >${tmpdir}/$(basename ${f})
    # Check whether the files include some important information
    for term in "POSTGRESQL\_ADMIN\_PASSWORD" volume 5432 ; do
      if ! cat ${tmpdir}/$(basename ${f}) | grep -F -q -e "${term}" ; then
        echo "ERROR: File /${f} does not include '${term}'."
        return 1
      fi
    done
  done
  # Check whether the files use the correct format
  if ! file ${tmpdir}/help.1 | grep -q roff ; then
    echo "ERROR: /help.1 is not in troff or groff format"
    return 1
  fi
  echo "  Success!"
  echo
}

function run_general_tests() {
  PGUSER=user PASS=pass POSTGRESQL_MAX_CONNECTIONS=42 POSTGRESQL_MAX_PREPARED_TRANSACTIONS=42 POSTGRESQL_SHARED_BUFFERS=64MB run_tests no_admin
  PGUSER=user1 PASS=pass1 ADMIN_PASS=r00t run_tests admin
  DB=postgres ADMIN_PASS=r00t run_tests only_admin
  # Test with arbitrary uid for the container
  DOCKER_ARGS="-u 12345" PGUSER=user2 PASS=pass run_tests no_admin_altuid
  DOCKER_ARGS="-u 12345" PGUSER=user3 PASS=pass1 ADMIN_PASS=r00t run_tests admin_altuid
  DB=postgres DOCKER_ARGS="-u 12345" ADMIN_PASS=rOOt run_tests only_admin_altuid
}

function run_all_tests() {
  for test_case in $TEST_LIST; do
    : "Running test $test_case"
    random_string test_random_id 6
    $test_case
  done;
}

# configuration defaults
POSTGRESQL_MAX_CONNECTIONS=100
POSTGRESQL_MAX_PREPARED_TRANSACTIONS=0
POSTGRESQL_SHARED_BUFFERS=32MB

# Run the chosen tests
TEST_LIST=${@:-$TEST_LIST} run_all_tests
